import os
import re

from loguru import logger
import openai
from functools import lru_cache
from domain.request import AgentPredictionResponseLog, AgentPredictionResponseLog

VIEWPORT_SIZE = (1920, 1080)
LOGS_DIR = "logs"

def expect_env_var(env_name: str) -> str:
    val = os.getenv(env_name)

    if val is None:
        raise EnvironmentError(f"Environment variable {env_name} not set")

    return val

def map_coords_to_screen(
        coords: tuple[int, int],
        scr_size: tuple[int, int], 
        target_size: tuple[int, int]
) -> tuple[int, int]:
    """
    Map coordinates from source size to destination size
    :param coords: (x, y) coordinates in the source space
    :param scr_size: (width, height) of the source space
    :param target_size: (width, height) of the destination space
    :return: (x, y) coordinates in the destination space
    """
    x, y = coords
    src_w, src_h = scr_size
    dst_w, dst_h = target_size

    scale_x = dst_w / src_w
    scale_y = dst_h / src_h

    mapped_x = int(round(x * scale_x))
    mapped_y = int(round(y * scale_y))

    return mapped_x, mapped_y

def _contains_chinese(text: str) -> bool:
    return any(
        '\u4e00' <= ch <= '\u9fff'      # CJK Unified Ideographs
        or '\u3400' <= ch <= '\u4dbf'   # CJK Extension A
        or '\U00020000' <= ch <= '\U0002A6DF'  # CJK Extension B
        for ch in text
    )


def fix_pyautogui_script(pyautogui_script: str) -> str:
    """
    Fix common issues in pyautogui scripts generated by the agent
    :param pyautogui_script: original pyautogui script
    :return: fixed pyautogui script
    """
    lines = pyautogui_script.splitlines()
    fixed_lines = []

    for i, line in enumerate(lines):
        # '<' is written as '>' https://github.com/asweigart/pyautogui/issues/198
        if ("pyautogui.write" in line or "pyautogui.press" in line or "pyautogui.typewrite" in line) and "<" in line:
            # Extract the string content from the write/typewrite/press call
            # Split by '<' and generate multiple statements
            # Match pyautogui.write("...", args) or pyautogui.typewrite("...", args) or pyautogui.press("...", args)
            match = re.search(r'(pyautogui\.(?:write|typewrite|press))\s*\(\s*(["\'])(.*)(\2)\s*(,\s*.*)?\)', line)
            if match:
                func_name = match.group(1)
                quote_char = match.group(2)
                content = match.group(3)
                trailing_args = match.group(5) if match.group(5) else ""
                indent = line[:len(line) - len(line.lstrip())]
                
                # Split content by '<' and generate separate statements
                parts = content.split('<')
                new_lines = []
                
                for j, part in enumerate(parts):
                    if part:  # Write the text part if not empty
                        new_lines.append(f'{indent}{func_name}({quote_char}{part}{quote_char}{trailing_args})')
                    if j < len(parts) - 1:  # Add hotkey for '<' except after the last part
                        new_lines.append(f'{indent}pyautogui.hotkey("shift", \',\')')

                    
                logger.warning(f"Detected and fixed '<' issue in line: {line}. Replaced with:\n{new_lines}")
                fixed_lines.extend(new_lines)
                continue
        
        if ("pyautogui.write" in line or "pyautogui.press" in line or "pyautogui.typewrite" in line) and _contains_chinese(line):
            # Extract the string argument using non-greedy match
            string_match = re.search(r'(["\'])((?:\\.|(?!\1).)*)\1', line)
            if string_match:
                indent = line[:len(line) - len(line.lstrip())]
                fixed_lines.append(f"{indent}import pyperclip")
                fixed_lines.append(f"{indent}# Using clipboard to handle Chinese characters")
                fixed_lines.append(f"{indent}pyperclip.copy({string_match.group(1)}{string_match.group(2)}{string_match.group(1)})")
                fixed_lines.append(f"{indent}pyautogui.hotkey('ctrl', 'v')")
                continue

        fixed_lines.append(line)

    return "\n".join(fixed_lines)

def convert_to_base64_image_url(b64_image: str) -> str:
    return f"data:image/png;base64,{b64_image}"

def log_agent_response(agent_name: str, agent_response_log: AgentPredictionResponseLog, start_new: bool = False):
    log_file_path = os.path.join(LOGS_DIR, agent_name, f"{agent_response_log.task_id}.jsonl")
    os.makedirs(os.path.dirname(log_file_path), exist_ok=True)

    mode = "w" if start_new else "a"
    with open(log_file_path, mode, encoding="utf-8") as f:
        f.write(agent_response_log.model_dump_json() + "\n")

@lru_cache(maxsize=1)
def get_openai_client() -> openai.OpenAI:
    return openai.OpenAI(
        base_url=expect_env_var("AZURE_OPENAI_BASE_URL"),
        api_key=expect_env_var("AZURE_OPENAI_API_KEY"),
    )

def create_embeddings(text: str | list[str]) -> list[list[float]]:
    client = get_openai_client()
    
    input_text = text if isinstance(text, list) else [text]
    
    response = client.embeddings.create(
        model="text-embedding-3-large",
        input=input_text
    )
    
    return [embedding.embedding for embedding in response.data]

def get_tool_calls_from_response(response) -> list:
    return list(filter(lambda o: o.type == "function_call", response.output))